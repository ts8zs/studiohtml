import{_ as e,p as o,q as d,Q as t,a1 as i}from"./framework-204010b2.js";const r="/studiohtml/Images/tutorials_imgs/node_imgs/model_move.jpg",a="/studiohtml/Images/tutorials_imgs/node_imgs/model_selected_pos.jpg",c="/studiohtml/Images/tutorials_imgs/node_imgs/model_euler.jpg",s="/studiohtml/Images/tutorials_imgs/node_imgs/model_rotate.jpg",l="/studiohtml/Images/tutorials_imgs/node_imgs/model_anchored.jpg",m={},n=i('<h1 id="位置控制" tabindex="-1"><a class="header-anchor" href="#位置控制" aria-hidden="true">#</a> 位置控制</h1><p>根据开发者的设计目标不同，可以对 <code>MiniStudio</code> 游戏中出现物理对象的位置进行多种方式的移动。</p><h2 id="对象位置" tabindex="-1"><a class="header-anchor" href="#对象位置" aria-hidden="true">#</a> 对象位置</h2><p>对象的全局位置由其三个 <code>Position</code> （位置）属性决定：<code>X</code>、<code>Y</code> 和 <code>Z</code>。此位置属性基于该对象的中心。</p><ul><li><p>若要在 <code>MiniStudio</code> 中移动对象的位置时，请使用 <code>Home</code> （主页）菜单选项卡中的 <code>Move</code> （移动）工具按钮。</p><p><img src="'+r+'" alt="model_move"></p></li><li><p>开发者也可以直接在 <code>Properties</code>（属性）窗口对 <code>Position</code> （位置）属性进行设置。</p><p><img src="'+a+'" alt="model_selected_pos"></p></li></ul><blockquote><p>请注意，在 MiniStudio 中，Y 轴向上，而在某些其他引擎中，Z 轴向上。</p></blockquote><h2 id="对象方向" tabindex="-1"><a class="header-anchor" href="#对象方向" aria-hidden="true">#</a> 对象方向</h2><p>对象的方向（旋转）由其三个 <code>LocalEuler</code> （方向）属性确定。和位置一样，此方向属性也是基于对象的中心。</p><ul><li><p>若要在 <code>Studio</code> 中更改某个对象的方向，请使用 <code>Home</code> （主页）菜单选项卡中的 <code>Rotate</code> （旋转）工具。</p><p><img src="'+c+'" alt="model_euler"></p></li><li><p>开发者也可以直接在 <code>Properties</code>（属性）窗口中对 <code>LocalEuler</code> （方向）属性进行设置（以度为单位）。</p><p><img src="'+s+'" alt="model_rotate"></p></li></ul><h2 id="锚固对象" tabindex="-1"><a class="header-anchor" href="#锚固对象" aria-hidden="true">#</a> 锚固对象</h2><p>默认情况下，所有物理对象都将遵守物理规则，也就是说其将在模拟重力作用下坠落或滑落斜坡等。若要将对象锁定至特定位置，使其即使在受到强烈碰撞或其它极端力量时仍然保持原位时，请在 <code>Home</code> （主页）/<code>Model</code> （模型）选项卡中或 <code>Propertie</code>（属性）窗口中将该对象的 <code>Physics/Anchored </code>（锚固）属性切换至打开。</p><p><img src="'+l+'" alt="model_anchored"></p><blockquote><p>需要注意的是，对于游戏中不应当移动的物体，应该始终对其进行锚固。即使是正常情况下不会移动的重物也应当遵循这一规则。这是因为锚固功能不仅能将对象锁定在特定位置，更可以让 <code>MiniStudio</code> 引擎忽略锚固部件的部分物理处理，从而提升游戏性能。</p></blockquote>',13);function p(_,h){return o(),d("div",null,[n,t(` ## 移动 Model（模型）

   Model（模型）由多个 BasePart|BasePart 组成，对其进行移动时，模型的边界框定义了其中心位置。但处理如下松树模型时，以其树干底端作为位置点更为合理。


   开发者在处理模型时，应当首先为其设置 Model/PrimaryPart|PrimaryPart，用来作为定位的基础（此操作可以直接在 Studio 中或通过脚本完成）。在上图示例中，松树模型的 Model/PrimaryPart|PrimaryPart 为其树干底端，以灰色轮廓勾勒表示。

   定义 Model/PrimaryPart|PrimaryPart 之后，就可以在脚本中调用模型的 Model/SetPrimaryPartCFrame|SetPrimaryPartCFrame() 方法，从而提供一个有效的 datatype/CFrame|CFrame 来对模型的位置或方向进行调整。 `)])}const P=e(m,[["render",p],["__file","NMPositionControl.html.vue"]]);export{P as default};
