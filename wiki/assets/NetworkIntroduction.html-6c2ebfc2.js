import{_ as r}from"./localscript_used-fbe6fc36.js";import{_ as i,M as n,p as a,q as u,R as c,t as o,N as d,V as l,a1 as t}from"./framework-5866ffd3.js";const s={},p=t('<h1 id="studio网络通信介绍" tabindex="-1"><a class="header-anchor" href="#studio网络通信介绍" aria-hidden="true">#</a> Studio网络通信介绍</h1><h2 id="ministudio联机模式" tabindex="-1"><a class="header-anchor" href="#ministudio联机模式" aria-hidden="true">#</a> MiniStudio联机模式</h2><p><strong>迷你世界联机主要是分为两种:</strong></p><ul><li>一种为 <strong>主客机模式</strong>，由主机不仅作为客户端还需要作为服务器，其他玩家为客户端</li><li>另外一种为 <strong>云服模式</strong>，云服作为服务器，每一位玩家都为客户端。</li></ul><p>服务器负责运行整个游戏世界并与客户端进行同步，接收客户端发来的信息，处理运算后对游戏世界进行改变。</p><h2 id="服务器与客户端如何通信" tabindex="-1"><a class="header-anchor" href="#服务器与客户端如何通信" aria-hidden="true">#</a> 服务器与客户端如何通信</h2><p>在游戏运行的时候，服务器会不停的更新所有的客户端</p><blockquote><p>例如当服务器脚本将天气进行了改变，此时服务器运行的游戏世界天气发生改变，此时也会通知所有客户端天气需要改变。</p></blockquote><p>客户端也可以向服务器发送消息</p><blockquote><p>例如玩家的按下W按键后向前移动会先在客户端进行处理玩家移动，然后通知服务器对应的结果，服务器根据结果对游戏世界进行改变，让玩家角色向前移动，同时这个变化会通过服务器同步至其他客户端，这样其他玩家也能看到这个角色的移动了</p></blockquote><p>所以分清楚代码应用在何处显得十分重要。</p><h3 id="客户端代码" tabindex="-1"><a class="header-anchor" href="#客户端代码" aria-hidden="true">#</a> 客户端代码</h3><p>客户端代码一般来说是用于处理玩家信息、玩家输入以及玩家界面的。响应玩家的输入并可能使服务器内容进行更改，但是首先会在客户端进行处理，这个可以给玩家快速的反馈。同样的，玩家UI界面也是有客户端代码进行处理</p><p><code>LocalScript</code> 只有在 <strong>客机</strong> 上且是 <strong>以下节点</strong> 的后代子节点（儿子节点，孙子节点 等等）代码逻辑才会执行</p><p><img src="'+r+'" alt="localscript_used"></p>',15),b=c("strong",null,"Player",-1),h=c("strong",null,"Player",-1),_=c("strong",null,"Player",-1),S=c("code",null,"LocalPlayer",-1),k=c("code",null,"Actor",-1),g=c("code",null,"LocalScript",-1),q=c("code",null,"LocalPlayer",-1),L=c("code",null,"Actor",-1),f=c("code",null,"LocalScript",-1),B=c("strong",null,"Player",-1),A=c("strong",null,"Player",-1),y=c("h3",{id:"服务器代码",tabindex:"-1"},[c("a",{class:"header-anchor",href:"#服务器代码","aria-hidden":"true"},"#"),o(" 服务器代码")],-1),N=c("p",null,"服务器代码主要负责游戏逻辑，玩家数据更新，场景改变等，是否需要服务器代码可从以下几个条件考虑",-1),E=c("ul",null,[c("li",null,"脚本代码是否会对游戏世界进行改变，例如添加模型，移除模型等，需要所有的客户端都会做出同样的改变"),c("li",null,"玩家较为重要的数据信息。此类信息可以放在服务器进行更改处理，用来保证外挂的干扰")],-1),M=c("p",null,[o("服务器代码在"),c("code",null,"Script"),o("中运行。只有当"),c("code",null,"Script"),o("属于以下实例的子类时，此类代码才会开始运行：")],-1),m=t('<h3 id="同步代码" tabindex="-1"><a class="header-anchor" href="#同步代码" aria-hidden="true">#</a> 同步代码</h3><p>MiniStudio与传统游戏相比，MiniStudio的开发者可以控制客户端（玩家）与主机或云服之间的通信。开发者可以通过节点的同步属性控制该节点是否与服务器内的属性进行同步。基础的通信原理是客户端对节点属性进行修改，然后属性变化会同步至主机，主机会再次同步给其他客户端。</p><p><strong>目前支持的同步模式如下</strong></p><ul><li><p><strong>SyncMode :</strong> | 同步模式 | 描述 | | ---- | ---- | | NORMAL | 正常模式（任意端修改了节点、属性 均会同步到其他端） | | DISABLE | 禁用（不同步，修改只会本地生效） | | ONLYHOST | 仅主机模式（只能主机发 只能客机收） | | ONLYREMOTE | 仅客机模式（只能客机发） |</p></li><li><p><strong>LocalSyncFlag :</strong> | 同步模式 | 描述 | | ---- | ---- | | ENABLE | 开启模式（设置开启才能同步） | | DISABLE | 禁用 | | NO_SEND | 禁止发送 | | NO_RECEIVE | 禁止接受 |</p></li></ul><h4 id="一、syncmode" tabindex="-1"><a class="header-anchor" href="#一、syncmode" aria-hidden="true">#</a> 一、SyncMode</h4><p><code>SyncMode</code>该属性只能通过 <code>Script</code>（服务器脚本）进行同步，<code>Localscript</code>无法对其进行修改。所以不同客户端的同一个节点的<code>SyncMode</code>是相同的</p><blockquote><p>实例：有一个模型节点<code>cube</code>，现在有两个客户端，以及一个服务器</p></blockquote><ul><li><p><strong>NORMAL:</strong> 该节点在任何一个客户端被修改后（通过<code>LocalScript</code>修改），都会同步给主机（云服）然后再次同步给其他客户端；使用<code>Script</code>会修改主机内该节点属性，并会同步给所有客户端。</p><blockquote><p>情况1：当<code>cube</code>位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性会被同步为<code>(10,10,10)</code>，云服会像B客户端进行同步，<code>B</code>客户端内该<code>cube</code>也会修改至<code>(10,10,10)</code>。</p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>Script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性会同步至AB两个客户端，都会变为<code>(10,10,10)</code></p></blockquote></li><li><p><strong>DISABLE:</strong> 则客户端属性的修改不会同步给其他客户端；使用<code>Script</code>对属性进行修改是不会同步给所有客户端的</p><blockquote><p>情况1：当cube位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性仍为<code>(0,0,0)</code>，<code>B</code>客户端也为<code>(0,0,0)</code></p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，<code>AB</code>两个客户端内<code>cube</code>仍在<code>(0,0,0)</code>位置</p></blockquote></li><li><p><strong>ONLYHOST:</strong> 只能通过<code>Script</code>进行属性修改才会同步给其他客户端，使用<code>Localscript</code>进行修改仅会修改当前客户端的属性</p><blockquote><p>情况1：当<code>cube</code>位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性仍为<code>(0,0,0)</code>，<code>B</code>客户端也为<code>(0,0,0)</code></p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，<code>AB</code>两个客户端内<code>cube</code>会同步至<code>(10,10,10)</code>位置</p></blockquote></li><li><p><strong>ONLYREMOTE:</strong> 使用<code>Script</code>可以修改主机（云服）的节点属性，但是客户端不会接收同步；使用<code>Localscript</code>会修改当前客户端的属性，同时同步改变主机的节点属性，但是主机不会同步给客户端。</p><blockquote><p>情况1：当<code>cube</code>位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性同步为<code>(10,10,10)</code>，但是<code>B</code>客户端仍为<code>(0,0,0)</code></p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>Script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，<code>AB</code>两个客户端内<code>cube</code>依然在<code>(0,0,0)</code></p></blockquote></li></ul><h4 id="二、localsyncflag" tabindex="-1"><a class="header-anchor" href="#二、localsyncflag" aria-hidden="true">#</a> 二、LocalSyncFlag</h4><p><code>LocalSyncFlag</code>该属性只能通过<code>Localscript</code>（客户端脚本）进行修改，<code>Script</code>无法对其进行修改。所以不同客户端的同一个节点的<code>LocalSyncFlag</code>可以设置为不同</p><blockquote><p>实例：有一个模型节点<code>cube</code>，现在有两个客户端，以及一个服务器</p></blockquote><ul><li><p><strong>NORMAL(与SyncMode相同):</strong> 该节点在任何一个客户端被修改后（通过<code>LocalScript</code>修改），都会同步给主机（云服）然后再次同步给其他客户端；使用<code>Script</code>会修改主机内该节点属性，并会同步给所有客户端。</p><blockquote><p>情况1：当<code>cube</code>位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性会被同步为<code>(10,10,10)</code>，云服会像B客户端进行同步，<code>B</code>客户端内该<code>cube</code>也会修改至<code>(10,10,10)</code>。</p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>Script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性会同步至AB两个客户端，都会变为<code>(10,10,10)</code></p></blockquote></li><li><p><strong>DISABLE(与SyncMode相同):</strong> 则客户端属性的修改不会同步给其他客户端；使用<code>Script</code>对属性进行修改是不会同步给所有客户端的</p><blockquote><p>情况1：当<code>cube</code>位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性仍为<code>(0,0,0)</code>，<code>B</code>客户端也为<code>(0,0,0)</code></p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>Script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，<code>AB</code>两个客户端内<code>cube</code>仍在<code>(0,0,0)</code>位置</p></blockquote></li><li><p><strong>NO_SEND:</strong> 只能通过<code>Script</code>进行属性修改才会同步给所有客户端，使用<code>Localscript</code>进行修改仅会修改当前客户端的属性</p><blockquote><p>情况1：当<code>cube</code>位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性仍为<code>(0,0,0)</code>，<code>B</code>客户端也为<code>(0,0,0)</code></p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>Script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，<code>AB</code>两个客户端内<code>cube</code>会同步至<code>(10,10,10)</code>位置</p></blockquote></li><li><p><strong>ONLYREMOTE:</strong> 使用<code>Script</code>可以修改主机（云服）的节点属性，但是客户端不会接收同步；使用<code>Localscript</code>会修改当前客户端的属性，同时同步改变主机的节点属性，但是主机不会同步给客户端。</p><blockquote><p>情况1：当<code>cube</code>位置属性通过A客户端的<code>Localscript</code>从原有的<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，服务器内该属性同步为<code>(10,10,10)</code>，但是B客户端仍为<code>(0,0,0)</code></p></blockquote><blockquote><p>情况2：当<code>cube</code>使用<code>Script</code>脚本将<code>cube</code>从原有的位置<code>(0,0,0)</code>修改为<code>(10,10,10)</code>后，<code>AB</code>两个客户端内<code>cube</code>依然在<code>(0,0,0)</code></p></blockquote></li></ul><h4 id="三、组合" tabindex="-1"><a class="header-anchor" href="#三、组合" aria-hidden="true">#</a> 三、组合</h4>',13),O=c("code",null,"LocalSyncFlag",-1),x=c("code",null,"SyncMode",-1);function P(F,I){const e=n("font");return a(),u("div",null,[p,c("ul",null,[c("li",null,[b,o(" 的 "),d(e,{color:"red"},{default:l(()=>[o("Backpack")]),_:1}),o("，如 "),d(e,{color:"red"},{default:l(()=>[o("Tool")]),_:1}),o(" 的子项")]),c("li",null,[h,o(" 的 "),d(e,{color:"red"},{default:l(()=>[o("character")]),_:1}),o(" 模型")]),c("li",null,[_,o(" 的 "),d(e,{color:"red"},{default:l(()=>[o("Actor")]),_:1}),o(" ，联机情况下只有 "),S,o(" 对应的 "),k,o(" 对象的 "),g,o(" 才会运行，非 "),q,o(" 的 "),L,o(" 即使有 "),f,o(" 也不会执行")]),c("li",null,[B,o(" 的 "),d(e,{color:"red"},{default:l(()=>[o("PlayerGui")]),_:1})]),c("li",null,[A,o(" 的 "),d(e,{color:"red"},{default:l(()=>[o("PlayerScripts")]),_:1})]),c("li",null,[d(e,{color:"red"},{default:l(()=>[o("LocalFirst")]),_:1}),o(" 服务")])]),y,N,E,M,c("ul",null,[c("li",null,[d(e,{color:"red"},{default:l(()=>[o("Workspace")]),_:1})]),c("li",null,[d(e,{color:"red"},{default:l(()=>[o("ServerScriptService")]),_:1})]),c("li",null,[o("玩家的 "),d(e,{color:"red"},{default:l(()=>[o("Backpack")]),_:1})])]),m,c("p",null,[o("开发者开发时可能会面对"),O,o("和"),x,o("冲突的情况，遵循的原理为: "),c("strong",null,[d(e,{color:"#FF6100"},{default:l(()=>[o("当两个属性都为可同步时才可同步属性；当两个都为可接收的时候，节点才会接收云服（主机）的同步属性")]),_:1})])])])}const D=i(s,[["render",P],["__file","NetworkIntroduction.html.vue"]]);export{D as default};
